{"organizations": ["Staff Writers Boston MA"], "uuid": "f8ba90eb10f46d510f8f9ef16c9e205cceb7d720", "thread": {"social": {"gplus": {"shares": 0}, "pinterest": {"shares": 0}, "vk": {"shares": 0}, "linkedin": {"shares": 0}, "facebook": {"likes": 0, "shares": 0, "comments": 0}, "stumbledupon": {"shares": 0}}, "site_full": "www.spacedaily.com", "main_image": "http://www.spxdaily.com/images-bg/chip-caches-small-memory-banks-bg.jpg", "site_section": "http://www.energy-daily.com/energy-daily.xml", "section_title": "Energy News - Energy Technology - Energy Business - Energy and the Environment", "url": "http://www.spacedaily.com/reports/First_new_cache_coherence_mechanism_in_30_years_999.html", "country": "US", "title": "First new cache-coherence mechanism in 30 years", "performance_score": 0, "site": "spacedaily.com", "participants_count": 0, "title_full": "First new cache-coherence mechanism in 30 years", "spam_score": 0.0, "site_type": "news", "published": "2015-09-17T09:40:00.000+03:00", "replies_count": 0, "uuid": "f8ba90eb10f46d510f8f9ef16c9e205cceb7d720"}, "author": "", "url": "http://www.spacedaily.com/reports/First_new_cache_coherence_mechanism_in_30_years_999.html", "ord_in_thread": 0, "title": "First new cache-coherence mechanism in 30 years", "locations": [], "entities": {"persons": [], "locations": [], "organizations": []}, "highlightText": "", "language": "english", "persons": [], "text": "First new cache-coherence mechanism in 30 years by Staff Writers Boston MA (SPX) Sep 15, 2015 File image. \nIn a modern, multicore chip, every core - or processor - has its own small memory cache, where it stores frequently used data. But the chip also has a larger, shared cache, which all the cores can access. \nIf one core tries to update data in the shared cache, other cores working on the same data need to know. So the shared cache keeps a directory of which cores have copies of which data. \nThat directory takes up a significant chunk of memory: In a 64-core chip, it might be 12 percent of the shared cache. And that percentage will only increase with the core count. Envisioned chips with 128, 256, or even 1,000 cores will need a more efficient way of maintaining cache coherence. \nAt the International Conference on Parallel Architectures and Compilation Techniques in October, MIT researchers unveil the first fundamentally new approach to cache coherence in more than three decades. Whereas with existing techniques, the directory's memory allotment increases in direct proportion to the number of cores, with the new approach, it increases according to the logarithm of the number of cores. \nIn a 128-core chip, that means that the new technique would require only one-third as much memory as its predecessor. With Intel set to release a 72-core high-performance chip in the near future, that's a more than hypothetical advantage. But with a 256-core chip, the space savings rises to 80 percent, and with a 1,000-core chip, 96 percent. \nWhen multiple cores are simply reading data stored at the same location, there's no problem. Conflicts arise only when one of the cores needs to update the shared data. With a directory system, the chip looks up which cores are working on that data and sends them messages invalidating their locally stored copies of it. \n\"Directories guarantee that when a write happens, no stale copies of the data exist,\" says Xiangyao Yu, an MIT graduate student in electrical engineering and computer science and first author on the new paper. \"After this write happens, no read to the previous version should happen. So this write is ordered after all the previous reads in physical-time order.\" \nTime travel What Yu and his thesis advisor - Srini Devadas, the Edwin Sibley Webster Professor in MIT's Department of Electrical Engineering and Computer Science - realized was that the physical-time order of distributed computations doesn't really matter, so long as their logical-time order is preserved. That is, core A can keep working away on a piece of data that core B has since overwritten, provided that the rest of the system treats core A's work as having preceded core B's. \nThe ingenuity of Yu and Devadas' approach is in finding a simple and efficient means of enforcing a global logical-time ordering. \"What we do is we just assign time stamps to each operation, and we make sure that all the operations follow that time stamp order,\" Yu says. \nWith Yu and Devadas' system, each core has its own counter, and each data item in memory has an associated counter, too. When a program launches, all the counters are set to zero. When a core reads a piece of data, it takes out a \"lease\" on it, meaning that it increments the data item's counter to, say, 10. As long as the core's internal counter doesn't exceed 10, its copy of the data is valid. (The particular numbers don't matter much; what matters is their relative value.) \nWhen a core needs to overwrite the data, however, it takes \"ownership\" of it. Other cores can continue working on their locally stored copies of the data, but if they want to extend their leases, they have to coordinate with the data item's owner. The core that's doing the writing increments its internal counter to a value that's higher than the last value of the data item's counter. \nSay, for instance, that cores A through D have all read the same data, setting their internal counters to 1 and incrementing the data's counter to 10. Core E needs to overwrite the data, so it takes ownership of it and sets its internal counter to 11. Its internal counter now designates it as operating at a later logical time than the other cores: They're way back at 1, and it's ahead at 11. The idea of leaping forward in time is what gives the system its name - Tardis, after the time-traveling spaceship of the British science fiction hero Dr. Who. \nNow, if core A tries to take out a new lease on the data, it will find it owned by core E, to which it sends a message. Core E writes the data back to the shared cache, and core A reads it, incrementing its internal counter to 11 or higher. \nUnexplored potential In addition to saving space in memory, Tardis also eliminates the need to broadcast invalidation messages to all the cores that are sharing a data item. In massively multicore chips, Yu says, this could lead to performance improvements as well. \"We didn't see performance gains from that in these experiments,\" Yu says. \"But that may depend on the benchmarks\" - the industry-standard programs on which Yu and Devadas tested Tardis. \"They're highly optimized, so maybe they already removed this bottleneck,\" Yu says. .", "external_links": [], "published": "2015-09-17T09:40:00.000+03:00", "crawled": "2015-09-18T01:19:28.059+03:00", "highlightTitle": ""}